결국 어떻게, 어디에 사용하느냐가 중요하다.
- 어떻게 만들 것인가?
	- Load
		- ResourceManager에서 파일 경로를 받아 생성 후 dvTexture로 리턴
		- Material 용도는 대부분 이렇게 생성
		- 문제는 Texture2D, RenderTexture의 Interface로 구성할 것이냐
	- 직접 생성
		- Texture2D
			- 크기, 포멧, 밉맵 생성여부를 전달하여 생성
			- 처음부터 색상이 초기화된 텍스처를 생성
			- 생성된 텍스쳐에 Data를 전달
			=> 애초에 White, Black이 아닌 빈 SRV를 만들 필요가 있나?
		- RenderTexture
- 어디에 사용하는가?
	- Texture2D
		- Materials
	- RenderTexture
		- GBuffer
		- Camera's RenderTarget
		- Cubemap

Texture의 구성
- ID3D11Texture2D 
- ID3D11RenderTargetView
- ID3D11DepthStencilView
- ID3D11ShaderResrouceView	

유니티
- Texture
	- 기본클래스다. Texture2D, RenderTarget이 상속한다.
	- Width, Height를 가진다.
	- wrapMode를 가진다.
	- filterMode를 가진다.
	- ansioLevel을 가진다.
	- mipMapBias를 가진다.(MipLevel이 아니다.)
- Textur2D
	- 텍스처를 생성하거나, 기존 텍스처 에셋을 수정하는데 사용한다.
	- format을 가진다.
	- mipmapCount를 가진다.
	- 빈 텍스쳐, 특정 색상 텍스쳐를 생성할 수 있다.
	- 생성된 텍스쳐의 특정 픽셀 데이터를 가져오거나 변경할 수 있다.
	- 생성된 텍스쳐의 크기를 변경할 수 있다.
	- LoadImage()로 byte 배열에서 Image를 Load할 수 있다.
	=> Cubemap이 없다.
- RenderTexture
: 무조건 DSV를 만드는 것인지, Cubemap은 어떻게 만드는 것인지 생각해보자.
	- 텍스쳐 위에 렌더링 결과물을 그리는데 사용한다.
	- IsCubemap으로 cubemap 사용 설정이 가능하다.
	- Rendering 된 값은 결국 사용해야 한다. 즉, ShaderResourceView도 가질 것이다.
	=> 검색을 해보니 Texture2D::LoadImage()로 RenderTexture를 읽어낸다... 
	=> 예제가 두 개나 있어 확실한 것 같은데... 이러면 cubemap이 에바잖아...
	=> 굳이 이를 따를 필요가 있나 싶다..
- Load
	- 1. Resources라는 객체를 통해 파일을 특정 리소스 타입으로 리턴받는다.
	예) Resources.Load<Texture2D>("Textures/" + name);
	- 2. File.IO를 통해 byte array로 읽은 후 Load한다.
	예) byte[] tex = System.IO.File.ReadAllBytes(path);
		texture.Load(tex);

RasterTek
- TextureClass
	- File을 읽어 ID3D11ShaderResourceView 생성
	- ShaderResourceView 리턴 함수 
- RenderTargetTextureClass
	- 전달받은 크기로 ID3D11Texture2D, ID3D11ShaderResourceView, ID3D11RenderTargetView 생성
	- 즉, TextureClass에 ID3D11RenderTargetView 생성 및 RenderTarget의 Bind와 Clear 함수 추가