RenderPath 제거하기
- Render의 Pass 조합으로 RenderPath를 구성한다는 생각은 너무 이상적이다.
	- 지원한느 모든 Pass를 구현한 후 RenderPath::Render에서 순서대로 조합하여 사용한다? 과연 가능한가?
- System들의 Update를 Runtime에서 직접 배치해 주어야 한다.
- Renderer::Update는 virtual로 타입으로 하고, 추가 Pass가 필요할 때 구체 클래스에서 구현한 후 Update를 직접 구성할 수 있다.
	- 예를 들면 Editor에서 EditorRenderer : public dive::Renderer를 만든 후 Pass_DebugDraw()를 구현한 후 Update에서 Pass들을 재구성할 수 있다.
	- System Interface를 뽑아내면 좋을 것 같지만... 현실적으론 어렵겠지?
		- 사실 System들을 Singleton으로 접근하는 것도 마음에 들지 않는다.

GraphicsDevice
- SwapChain, Device, DeviceContext를 생성 및 관리한다.
- 현재 BackBuffer RTV, DSV도 관리하고 있다.
	- App의 Resolution은 바로 이 BackBuffer의 Size를 의미한다.
	- 따라서 윈도우의 크기 조절은 이 BackBuffer의 크기 조절을 의미한다.
	- 하지만 RTV, DSV를 직접 관리해야 하는가에 대한 의문이 있다.
- Begin / End Scene이 꼭 필요한가에 대한 의문이 있다.
	- 일단 Editor에서 ImGUI이 때문에 BackBuffer에 먼저 그릴 필요가 있을 것 같다.
	- Deferred Shading의 경우 결국 마지막에만 BackBuffer에 Swap할 것 같다. 좀 더 알아볼 필요가 있다.

Renderer
- GraphicsDevice, GBuffer 및 Resource들을 생성 및 관리한다.
- 다양한 Pass를 구성하면 RenderPath에서 이들의 조합으로 화면을 그려낸다. => 이상적인 목표

- Begin / EndScene의 구현에 대해 생각을 정리 중이다.(Renderer_Pass.cpp)
- Camera는 자신이 그릴 Screen의 크기를 스스로 찾아야 한다.
	- 현재 이 때문에 Sandbox 실행이 되지 않는다.
	- RenderTarget(Texture), GBuffer, Backbuffer 순으로 찾아야 할 것이다. 
	=> 결국 아래의 '크기에 대한 생각'과 연결된다.

크기에 대한 생각
- Backbuffer의 크기는 결국 App의 Client Size다.
	- WM_SIZE에 반응하는 건 Backbuffer Size가 맞다.
	- 결국 이 값이 App의 Resolution이다.
- GBuffer의 크기는 Backbuffer와 다를 수 있다.
	- Editor가 그렇다. 이럴땐 GBuffer에 Resize 함수를 두던가 Initialize를 새로 하는게 맞는 것 같다.
- 개별 RenderTexture의 크기는 생성시 결정하는 게 맞는 것 같다.
- Camera가 RenderTarget의 크기를 알아내는 방법
	- Camera의 ViewMatrix, Viewport 계산에 사용된다.
	- 1. RenderTexture가 있다면 크기를 얻어 온다.
	- 2. 없다면 GBuffer 객체를 통해 크기를 얻어 온다.
	- 3. 그것도 없다면 Resolution을 얻어온다.

RenderTexture의 문제
- RenderTarget으로 쓰려면 결국 Shader가 달라야 한다. 아마 최종 출력 Shader가 될 것이다.
- 마지막 Shader Pass에서 RenderTarget을 전달해야 한다.
	- 일단 생성을 App(Eidtor)에서 할 지, Renderer에서 일괄 생성할 지 결정하지 못했다.
=> Deferred Shading에 대한 이해부터 완벽하지 않다.
=> Directional Light부터 보면 될 것 같다.

Camera
- Camera는 여러대가 존재할 수 있다.
	- 여러대가 동시에 Activate 될 수 있다.
		- 기본적으로 RenderTarget에 그리지만, 그냥 화면에 그릴수 도 있다.
		=> 유니티 예제를 확인한 후 내린 판단이다. 애초에 Camera에서 RenderTarget을 설정 유무를 결정할 수 있다.
		- 어찌되었던 간에 카메라를 기준으로 Draw Pass가 구성될 것 같다.
- Editor는 기본적으로 카메라를 가진다. 하지만 이는 게임의 카메라가 아니다!!!
	- Editor의 Hierarchy에도 보이지 않게 수정하고 싶다.
	=> 좀 깊이 생각해보아야 할 것 같다. 어쩌면 Runtime을 App와 Editor Mode로 나누어 실행시켜야 할 수 있다.
	- 현재 Camera를 추가하면 가장 마지막에 추가된 카메라를 기준으로 렌더링 한다.
- 뭐가 잘못된건지 모르겠는데, Orthographic Projection이 적용되지 않는다.
	- ScreenSize와 ViewSize가 달라야 할 것 같은데... 
	=> 일단 이는 유니티에서 Orthographic을 어떻게 적용하느냐를 본 후 결정하자. Perspective가 아닌 경우 사용하지 않는 변수가 있기 때문이다.
- Clear Flag??에 대해 알아봐야 한다. Clear Color을 지니고, Cubempa을 설정하는 걸 보면... Camera에서 RenderTarget을 Clear하는 것 같다.
- Culling Mask도 뭔지 봐야 한다. Frustum Cull과 관련이 있으려나...
=> 아니다. 이건 그려낼 Layer를 추려내는 용도다.

Scene
- Scene 전환시 이전 Scene 정보를 사용하는 버그가 있다.
	- Scene은 SceneManager가 관리한다.

Behavior
- 유니티에는 Component를 상속하는 Behavior이라는 클래스가 있다.
	- 다른 Component와 달리 활성화 유무를 지정할 수 있다. 
	- 카메라 등이 이를 상속한다.
- Inspector에서 활성화 유무를 설정하는 Component들이 존재하는 이유다.
=> Tag 설정도 아직 안했고... 결국 Object부터 Component까지 유니티 인터페이스를 좀 더 견고하게 받아야 들어야 할 거 같다.
=> Frustum Culling은 기본이고, Occlusion Culling이란 것의 적용 유무를 선택할 수 있는 것 같다.