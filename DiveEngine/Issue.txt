크기에 대한 생각
결국 GraphicsDevice가 Backbuffer의 크기를
GBuffer가 자신의 크기를 각자 관리토록 하였다.
하지만 아직도 GBuffer의 Initialize 및 Resize를 어디에서 어떻게 수행할 지
Eidtor의 Scene에서 출력할 RenderTexture는 누가 관리하고 어떻게 구현할 지 결정하지 못했다.

RenderTexture의 문제
- RenderTarget으로 쓰려면 결국 Shader가 달라야 한다. 아마 최종 출력 Shader가 될 것이다.
- 마지막 Shader Pass에서 RenderTarget을 전달해야 한다.
	- 일단 생성을 App(Eidtor)에서 할 지, Renderer에서 일괄 생성할 지 결정하지 못했다.
=> Deferred Shading에 대한 이해부터 완벽하지 않다.
=> Directional Light부터 보면 될 것 같다.

Camera
- Camera는 여러대가 존재할 수 있다.
	- 여러대가 동시에 Activate 될 수 있다.
		- 기본적으로 RenderTarget에 그리지만, 그냥 화면에 그릴수 도 있다.
		=> 유니티 예제를 확인한 후 내린 판단이다. 애초에 Camera에서 RenderTarget을 설정 유무를 결정할 수 있다.
		- 어찌되었던 간에 카메라를 기준으로 Draw Pass가 구성될 것 같다.
- Editor는 기본적으로 카메라를 가진다. 하지만 이는 게임의 카메라가 아니다!!!
	- Editor의 Hierarchy에도 보이지 않게 수정하고 싶다.
	=> 좀 깊이 생각해보아야 할 것 같다. 어쩌면 Runtime을 App와 Editor Mode로 나누어 실행시켜야 할 수 있다.
	- 현재 Camera를 추가하면 가장 마지막에 추가된 카메라를 기준으로 렌더링 한다.
- 뭐가 잘못된건지 모르겠는데, Orthographic Projection이 적용되지 않는다.
	- ScreenSize와 ViewSize가 달라야 할 것 같은데... 
	=> 일단 이는 유니티에서 Orthographic을 어떻게 적용하느냐를 본 후 결정하자. Perspective가 아닌 경우 사용하지 않는 변수가 있기 때문이다.
- Clear Flag??에 대해 알아봐야 한다. Clear Color을 지니고, Cubempa을 설정하는 걸 보면... Camera에서 RenderTarget을 Clear하는 것 같다.
- Culling Mask도 뭔지 봐야 한다. Frustum Cull과 관련이 있으려나...
=> 아니다. 이건 그려낼 Layer를 추려내는 용도다.

Scene
- Scene 전환시 이전 Scene 정보를 사용하는 버그가 있다.
	- Scene은 SceneManager가 관리한다.

Behavior
- 유니티에는 Component를 상속하는 Behavior이라는 클래스가 있다.
	- 다른 Component와 달리 활성화 유무를 지정할 수 있다. 
	- 카메라 등이 이를 상속한다.
- Inspector에서 활성화 유무를 설정하는 Component들이 존재하는 이유다.
=> Tag 설정도 아직 안했고... 결국 Object부터 Component까지 유니티 인터페이스를 좀 더 견고하게 받아야 들어야 할 거 같다.
=> Frustum Culling은 기본이고, Occlusion Culling이란 것의 적용 유무를 선택할 수 있는 것 같다.