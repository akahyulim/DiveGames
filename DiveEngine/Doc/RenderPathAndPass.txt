
생각해 볼 사항
- Pass를 어디에 만드느냐?!
	- 결국 RenderPath를 App에서 구현토록 하느냐, Engine에 구현된 것을 사용토록 하느냐이다. 
		- 즉, Texture를 어디에서 생성 및 관리하느냐, Renderer에서 Draw()를 얼마나 쪼개느냐의 차이
	- GBuffer Pass만 Renderer에 구현하여 Black box화?하고 Post Processing Pass는 RenderPath에서 구성?
		- 유니티의 경우 이러한 구조 같다.
			- Shadow, Lighting까지 끝마친 결과물을 하나의 RenderTexture로 혼합하고, 여기에 후처리를 가하는 것 같다.
				- 참고서의 경우에도 Deferred에 Lighting이 포함되어 있고, Shadow Map 이후 부분부터 Post Procssing 챕터라 명명 했다.
		- 그런데 Wicked 조차 Renderer에 Post Proecss 관련 함수가 존재한다.

		

Unity에서의 RenderPath와 Pass
: 참고(https://forum.unity.com/threads/what-is-a-render-pass-in-simple-words.715004/)
- Render Path & Pipeline
	- Render Path
		- Forward, Deferred
		- Black box 구현
	- Render Pipeline
		- Universal = LightWeight(LWRP), HighDefinition(HDRP)
		- C#으로 구현되어 있으며 수정 가능
	- 즉, 여기에서 Pipeline은 Path 이후 더 발전된 형태의 Rendering 구현을 일컫는 용어이다.
- Pass
	- Shader Pass
		- ID3DXEffect의 Pass와 유사하다.
		- State, Vertex & Pixel Shader 등으로 구성
	- Render Pass
		- Render Target에 그리는 하나의 단위를 의미
		- 설명에서는 카메라 깊이 텍스쳐, 그림자 맵 생성 등을 언급한다.

RenderPass
	- Spartan
		- Pass_XXX()로 구현한다.
		- 내부에서 오브젝트를 구분하고 각종 리소스를 Bind한 후 Draw를 호출하여 그린다.
			- RenderTarget 역시 Set & Clear한다.
		- 이러한 묶음으로 GBuffer, Post Proecssing을 구현한다.
	- Wicked
		- RenderPath에서 관리한다.
		- RenderTarget의 묶음이다.
			- ResizeBuffers()를 통해 Resource를 (재)생성할 때 같이 구성한다.
		- GraphicsDevice::RenderPassBegin()에 전달하여 Set & Clear를 수행한다.
			- GraphicsDevice::RenderPassEnd()에 전달하여 Set을 해제한다.
		- Begin()과 End() 사이에서 Renderer의 Bind(), Draw()를 호출해 RenderTarget에 그린다. 
	- 결국 그려지는 행위 자체 그리고 그려지는 장소(Target Texture)를 기준으로 Pass를 나누었다고 볼 수 있다.
	=> 즉, 둘 다 Render Pass이다.