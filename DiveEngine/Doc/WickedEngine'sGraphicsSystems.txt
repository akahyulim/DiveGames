GraphicsDevice
- SwapChain, Device, DeviceContext를 생성 및 관리한다.
- Device 설정을 관리한다.
	- Resolution, VSync, Format etc
- 각종 Resource의 생성 함수를 지원한다.
	- 이때 shared_ptr로 생성하여 가비지 컬렉션을 적용한다.
	- Buffer의 Map / Unmap도 지원한다.
- 각종 Resource의 Bind 함수를 지원한다.
- 각종 Draw 함수를 지원한다.
	- 랩핑 함수라고 보면 된다.

Renderer
: This is a collection of graphics technique implentations and functions to draw a scene, shadows, post processes and other things.
It is also the manager of the GraphicsDevice instance, and provides other helper functions to load shaders from files on disk.
- GraphicsDevice와 Scene 그리고 각종 GameObject들을 활용하여 Draw(Pass)를 구성한다.
- 기본적인 Resource 배열들을 관리한다.
	- Shader, Texture, Sampler, States, GPUBuffer, InputLayout
		- GPUBuffer는 Constant Buffer 같다. Shader Resource는 뭐지...
		- Texture의 용도가 뭔지 아직 모르겠다.
- Visibility를 Update한다.
	- Scene의 Object들을 Camera로 Culling한다.
	- Flag에 맞춰 저장한다.
	- 이 과정을 수행만 할 뿐, 관리는 RenderPath가 한다.
- Update Data
	- UpdatePerFrameData: RenderPath에서 Scene Update 후에 호출되며 CullFrustum등을 수행한다???
	- UpdateRenderData: RenderPath에서 Render 초기에 호출되며...???
	=> 이 두 함수는 RenderPath 구체 클래스에서 구성한 동일한 Constant Buffer를 사용하고 있다.
- DrawXXX
	- 특정 화면을 Draw한다.
	- DrawScene
		- Viewport는 외부에서 Bind되어야 한다.
		- Camera에서 보이는 대상을 추려 그려낸다. 즉, 컬링이 적용되고 카메라와의 거리에 맞춰 정렬된다.
		=> 컬링 및 정렬이 이미 이루어진 상태의 Visibility를 전달받는 것 같다.
		- 내부에서 Visibility 별로 따로 그려지는 것 같다. 그리고 좀 더 복잡하게 흘러간다...


RenderPath
- Renderer의 각종 DrawPass를 조합하여 출력 화면을 만든다.
	- MultiThread Rendering 때문에 분석이 어렵다.
- 각종 Texture를 가진다.
	- GBuffer로 사용할 개별 Texture들인 것 같다.
- Visibility 객체들을 관리한다.
	- 좀 더 정확하게 보자면 관리는 자신이 하지만 정리는 Renderer에 넘긴다.
	- 그리고 Render에서 Renderer의 Draw에 전달한다.
- Render
	- RenderPassBegin() / RenderPassEnd()로 묶는다.
		- RenderTarget의 설정 및 클리어 구문이다.
	- Viewport를 형성 한 후 Bind한다.
		- Viewport의 크기 설정은 RenderTarget을 통해 지정된다.
	- 그려질 대상을 관련 Draw 함수에 전달하여 그려낸다.

RenderPass
- RenderTarget or DepthsStencil View들이다.
- RenderPath에서 각종 ResourceBuffer들과 함께 생성된다.
	- 앞서 생성된 Texture(RenderTargetView, DepthStencilView)들의 조합을 RenderPass라는 객체에 저장하는 형태이다.
- RenderPath::Render()에서 Pass별로 RenderPassBegin()에 전달된다.
	- 그러면 GraphicsDevice에서 Texture 포인터를 얻은 후 타입에 맞게 Clear 후 RenderTarget으로 Set한다.
	- RenderPassEnd()는 OMSetRenderTargets()에 nullptr을 전달하여 초기화하는 것이다.