
목표 - Deferred Shading으로 Legacy Lighting을 구현하면서 GraphicsDevice, Renderer, RenderPath 기능 구분하기

- 일단 Texture부터 만들자.
- RenderPass를 만들자.
	- Texture에서 DepthBuffer를 구분할 수 있어야 한다.


[Light 없는 GBuffer Rendering]
GraphicsDevice
	- 결국 Device와 Context 생성 및 관리를 주요 기능으로 축소된 형태다.
	- 물론 Backbuffer를 직접 관리(RTV 전달 및 Buffer Size 대응)하는 기능이 있다.
Renderer
	- States의 생성 및 Bind 그리고 관리
		- 생성은 직접 Device를 이용해 만드는 방법으로 가야할 것 같다.
		- Bind는 PipelineState를 활용하는 것이 일반적인 것 같다.
		- State는 Renderer가 관리하는 형태인 듯 하다.
	- 나머지 Resource의 생성 및 Bind
		- 생성은 매개변수로 Device를 받아 만들도록 하자.
		- Bind의 경우 Com객체를 리턴할지 아니면 DeviceContext를 받아 직접 연결할지 정해야 한다.
			- 참고 엔진들은 전부 DrawXXX류 함수에서 Visibility의 Component::GetXXX() 함수를 통해 Resource(Buffer)를 획득한 후 DeviceContext로 Bind한다.
			- 유니티의 경우 Renderer가 Component이다. 이름으로 유추하자면 직접 Bind 후 Draw까지 할 것 같다.
	- Draw 구성
		- Wicked
			- Scene, Shadowmap, Sun, Sky, DebugWorld, SoftParticles 처럼 Deferred와 후처리로 묶어 놓은 것 같다.
				- 내부에서는 Visibility를 Bind한 후 Draw로 그린다.
		- Spartan
			- Pass_Main()에서 다양한 Pass들을 순서대로 조합하여 그린다. 즉, Pass_Main()이 Wicked의 RenderPath::Render()와 비슷한다.
				- Pass_XXX는 Gbuffer와 Post Processing으로 나뉜다.
				- Pass_XXX의 내부에서는 PipelineState를 생성 및 Bind한 후 Draw로 그린다.
		- 따지고 보니 둘 다 비슷한 형태이다.
RenderPath
	- GBuffer에 대응하는 Texture 관리
		=> Texture부터 만들어야 한다.
그외
	- Scene RenderTexture를 Shader의 RenderTarget으로 명시화하여야 한다.
