현재 문제점
	- 유니티처럼 구현하면 사용자는 딱 구분해서 사용해야 하는데...
	- 그리고 Format에 따른 구분 역시 좀 더 신경써야 한다.
	- 여전히 Cubemap에 대해선 넘기는 중...

Texture의 구성
- ID3D11Texture2D 
- ID3D11RenderTargetView
- ID3D11DepthStencilView
- ID3D11ShaderResrouceView

역시 용도를 확실히 정리해 두어야 할 것 같다.
- Material
: 대부분 Import(Load)하여 생성한다.
	- Shader Resource View로 활용한다.
	- Diffuse: 손맵이다. Albedo랑은 다르다.
	- Normal & Height Map
		- 둘 다 Bump Map이지만 표현방법이 달라 색도 다르다.
		- Format은 다 동일해도 되나?
		- Import할 때 Normal 혹은 Height Map임을 설정해야 한다.
- RenderTarget
	- SRV는 물론 RTV + DSV로 활용한다.
	- 역시 용도별 Format이 다를 수 밖에 없다.
	- GBuffer
	- Camera's RenderTarget
	- Cubemap
		- Import도 가능해야 한다.

	

유니티
- Texture
	- 기본클래스다. Texture2D, RenderTarget이 상속한다.
	- Width, Height를 가진다.
	- wrapMode를 가진다.
	- filterMode를 가진다.
	- ansioLevel을 가진다.
	- mipMapBias를 가진다.(MipLevel이 아니다.)
- Textur2D
	- 텍스처를 생성하거나, 기존 텍스처 에셋을 수정하는데 사용한다.
	- format을 가진다.
	- mipmapCount를 가진다.
	- 빈 텍스쳐, 특정 색상 텍스쳐를 생성할 수 있다.
	- 생성된 텍스쳐의 특정 픽셀 데이터를 가져오거나 변경할 수 있다.
	- 생성된 텍스쳐의 크기를 변경할 수 있다.
	- LoadImage()로 byte 배열에서 Image를 Load할 수 있다.
	=> Cubemap이 없다.
- RenderTexture
: 무조건 DSV를 만드는 것인지, Cubemap은 어떻게 만드는 것인지 생각해보자.
	- 텍스쳐 위에 렌더링 결과물을 그리는데 사용한다.
	- IsCubemap으로 cubemap 사용 설정이 가능하다.
	- Rendering 된 값은 결국 사용해야 한다. 즉, ShaderResourceView도 가질 것이다.
	=> 검색을 해보니 Texture2D::LoadImage()로 RenderTexture를 읽어낸다... 
	=> 예제가 두 개나 있어 확실한 것 같은데... 이러면 cubemap이 에바잖아...
	=> 굳이 이를 따를 필요가 있나 싶다..
- Load
	- 1. Resources라는 객체를 통해 파일을 특정 리소스 타입으로 리턴받는다.
	예) Resources.Load<Texture2D>("Textures/" + name);
	- 2. File.IO를 통해 byte array로 읽은 후 Load한다.
	예) byte[] tex = System.IO.File.ReadAllBytes(path);
		texture.Load(tex);

RasterTek
- TextureClass
	- File을 읽어 ID3D11ShaderResourceView 생성
	- ShaderResourceView 리턴 함수 
- RenderTargetTextureClass
	- 전달받은 크기로 ID3D11Texture2D, ID3D11ShaderResourceView, ID3D11RenderTargetView 생성
	- 즉, TextureClass에 ID3D11RenderTargetView 생성 및 RenderTarget의 Bind와 Clear 함수 추가